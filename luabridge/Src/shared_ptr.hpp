/*
 * shared_ptr.hpp - Copyright (C) 2007 by Nathan Reed
 * Smart pointer with reference counting.
 * This is compatible with boost::shared_ptr, in the sense that it implements
 * a strict subset of boost_shared_ptr's functionality.
 */

#ifndef SHARED_PTR_HPP
#define SHARED_PTR_HPP

// Disable "unreachable code" warning generated by unordered_map in release build
#ifdef _MSC_VER
#	pragma warning (push)
#	pragma warning (disable: 4702)
#	include <unordered_map>
#	pragma warning (pop)
#else
#	include <ext/unordered_map>
#endif

namespace luabridge
{
	template <typename T>
	class shared_ptr
	{
		T* ptr;
	public:
		shared_ptr (T* ptr_);

		// Copy constructors: the first one is necessary to write out,
		// since the compiler doesn't recognize the second as a copy ctor
		shared_ptr (const shared_ptr<T>& rhs);
		template <typename U> shared_ptr (const shared_ptr<U>& rhs);

		template <typename U> shared_ptr& operator =
			(const shared_ptr<U> & rhs);

		T* get () const;
		T* operator * () const;
		T* operator -> () const;
		long use_count () const;

		void reset ();
		~shared_ptr ();
	};

	// Include implementation
/*
 * shared_ptr.hpp - Copyright (C) 2007 by Nathan Reed
 * Implementation of shared_ptr class template.
 */

#include <unordered_map>
 
// Declaration of container for the refcounts
#ifdef _MSC_VER
	typedef std::unordered_map<const void *, int> refcounts_t;
#else
	struct ptr_hash
	{
		size_t operator () (const void * const v) const
		{
			static __gnu_cxx::hash<unsigned int> H;
			return H((unsigned int)v);
		}
	};
	typedef __gnu_cxx::unordered_map<const void *, int, ptr_hash> refcounts_t;
#endif
extern refcounts_t refcounts_;

/*
 * shared_ptr <T> implementation
 */

template <typename T>
shared_ptr<T>::shared_ptr (T* ptr_): ptr(ptr_)
{
	++refcounts_[ptr];
}

template <typename T>
shared_ptr<T>::shared_ptr (const shared_ptr<T>& rhs): ptr(rhs.get())
{
	++refcounts_[ptr];
}

template <typename T>
template <typename U>
shared_ptr<T>::shared_ptr (const shared_ptr<U>& rhs): ptr(rhs.get())
{
	++refcounts_[ptr];
}

template <typename T>
template <typename U>
shared_ptr<T>& shared_ptr<T>::operator = (const shared_ptr<U>& rhs)
{
	reset();
	ptr = static_cast<T*>(rhs.get());
	++refcounts_[ptr];
	return *this;
}

template <typename T>
T* shared_ptr<T>::get () const
{
	return ptr;
}

template <typename T>
T* shared_ptr<T>::operator * () const
{
	return ptr;
}

template <typename T>
T* shared_ptr<T>::operator -> () const
{
	return ptr;
}

template <typename T>
long shared_ptr<T>::use_count () const
{
	return refcounts_[ptr];
}

template <typename T>
void shared_ptr<T>::reset ()
{
	if (!ptr) return;
	if (--refcounts_[ptr] <= 0)
		delete ptr;
	ptr = 0;
}

template <typename T>
shared_ptr<T>::~shared_ptr ()
{
	reset();
}

}

#endif
